'''
Date: 2025-02-20 10:49:33
LastEditors: BHM-Bob 2262029386@qq.com
LastEditTime: 2025-02-20 18:53:58
Description: 
'''
import numpy as np
from tqdm import tqdm


def inner_product(coords1, coords2, weights, backend = None):
    """
    Calculate the inner product of two structures.

    Parameters:
    - coords1: np.ndarray, shape (N, 3)
    - coords2: np.ndarray, shape (N, 3)
    - weights: np.ndarray, shape (N,), weights for each component

    Returns:
    - A: np.ndarray, shape (3, 3), inner product matrix
    - E0: float, 0.5 * (G1 + G2)
    """
    backend = backend or np
    if weights is None:
        weights = backend.ones(len(coords1))
    
    # Center the coordinates
    coords1_centered = coords1 - backend.mean(coords1, 0)
    coords2_centered = coords2 - backend.mean(coords2, 0)
    
    # Calculate G1 and G2
    G1 = backend.sum(weights[:, None] * (coords1_centered ** 2))
    G2 = backend.sum(weights[:, None] * (coords2_centered ** 2))
    E0 = 0.5 * (G1 + G2)
    
    # Compute the inner product matrix A (3x3)
    A = backend.dot((coords1_centered * weights[:, None]).T, coords2_centered)
    return A, E0


def calc_rmsd_and_rotation(ref, conf, weights=None, backend=None):
    """
    Calculate the RMSD and optimal rotation matrix.

    Parameters:
    - ref: np.ndarray, shape (N, 3), reference coordinates
    - conf: np.ndarray, shape (N, 3), candidate coordinates
    - weights: np.ndarray, shape (N,), optional weights

    Returns:
    - rmsd: float, RMSD value
    - rot_matrix: np.ndarray, shape (3, 3), optimal rotation matrix (flattened)
    """
    backend = backend or np
    if weights is None:
        weights = backend.ones(len(ref))
    
    # Calculate inner product matrix and E0
    A, E0 = inner_product(ref, conf, weights)
    
    # Compute SVD of matrix A
    U, _, Vt = backend.linalg.svd(A)
    
    # Ensure right-handed rotation matrix
    det = backend.linalg.det(U @ Vt)
    if det < 0:
        Vt[-1, :] *= -1
        det = backend.linalg.det(U @ Vt)
    
    # Compute rotation matrix
    R = U @ Vt
    
    # Calculate RMSD
    ref_centered = ref - backend.mean(ref, 0)
    conf_centered = conf - backend.mean(conf, 0)
    rmsd = backend.sqrt(backend.mean(weights * (backend.linalg.norm(ref_centered - conf_centered @ R.T, 1) ** 2)))
    
    return rmsd


def rmsd(a, b, weights=None, center=False, superposition=False, backend: str = 'numpy'):
    r"""Returns RMSD between two coordinate sets `a` and `b`.

    `a` and `b` are arrays of the coordinates of N atoms of shape
    :math:`N times 3` as generated by, e.g.,
    :meth:`MDAnalysis.core.groups.AtomGroup.positions`.

    Parameters
    ----------
    a : array_like
        coordinates to align to `b`
    b : array_like
        coordinates to align to (same shape as `a`)
    weights : array_like (optional)
        1D array with weights, use to compute weighted average
    center : bool (optional)
        subtract center of geometry before calculation. With weights given
        compute weighted average as center.
    superposition : bool (optional)
        perform a rotational and translational superposition with the fast QCP
        algorithm [Theobald2005]_ before calculating the RMSD; implies
        ``center=True``.

    Returns
    -------
    rmsd : float
        RMSD between `a` and `b`

    """

    a = np.asarray(a, dtype=np.float64)
    b = np.asarray(b, dtype=np.float64)
    N = b.shape[0]
    if a.shape != b.shape:
        raise ValueError('a and b must have same shape')

    # superposition only works if structures are centered
    if center or superposition:
        # make copies (do not change the user data!)
        # weights=None is equivalent to all weights 1
        a = a - np.average(a, axis=0, weights=weights)
        b = b - np.average(b, axis=0, weights=weights)

    if weights is not None:
        if len(weights) != len(a):
            raise ValueError('weights must have same length as a and b')
        # weights are constructed as relative to the mean
        weights = np.asarray(weights, dtype=np.float64) / np.mean(weights)

    if superposition:
        return calc_rmsd_and_rotation(a, b, weights)
    else:
        if weights is not None:
            return np.sqrt(np.sum(weights[:, np.newaxis]
                                  * ((a - b) ** 2)) / N)
        else:
            return np.sqrt(np.sum((a - b) ** 2) / N)


def pairwise_rmsd(traj: np.ndarray, traj2: np.ndarray = None, block_size: int = 100, backend: str = 'numpy', verbose: bool = False):
    """
    Calculate pairwise RMSD between atoms in a trajectory.
    
    Parameters:
        - traj (np.ndarray): Trajectory data with shape (n_frames, n_atoms, 3).
    
    Returns:
        np.ndarray: Pairwise RMSD matrix with shape (n_frames, n_frames), [i, j] representing the RMSD between frames i and j.
    """
    traj2 = traj2 or traj
    n_frames, n_atoms, _ = traj.shape
    K = n_frames // block_size
    if backend == 'numpy':
        rmsd_matrix = np.zeros((n_frames, n_frames), dtype=np.float32)
    elif backend in {'torch', 'cuda'}:
        import torch
        traj = torch.from_numpy(traj)
        traj2 = torch.tensor(traj2)
        rmsd_matrix = torch.zeros((n_frames, n_frames), dtype=torch.float32)
    # calcu rmsd for each block
    for i in tqdm(range(K), total=K, desc='Calculating RMSD matrix', leave=False, disable=not verbose):
        # prepare block i
        start_i = i * block_size
        end_i = (i + 1) * block_size if i < K - 1 else n_frames
        block_i = traj[start_i:end_i]
        if backend == 'cuda':
            block_i = block_i.cuda()
        # calcu rmsd for block-i series
        for j in range(K):
            # prepare block j
            start_j = j * block_size
            end_j = (j + 1) * block_size if j < K - 1 else n_frames
            block_j = traj2[start_j:end_j]
            # calculate RMSD
            if backend == 'numpy':
                diff = block_i[:, np.newaxis] - block_j[np.newaxis]
                rmsd = np.sqrt(np.mean(np.sum(diff ** 2, axis=-1), axis=-1))
            elif backend == 'torch':
                diff = block_i[:, None] - block_j[None]
                rmsd = torch.sqrt(torch.mean(torch.sum(diff ** 2, dim=-1), dim=-1))
            elif backend == 'cuda':
                diff = block_i[:, None] - block_j[None].cuda()
                rmsd = torch.sqrt(torch.mean(torch.sum(diff ** 2, dim=-1), dim=-1)).cpu()
            # fill rmsd matrix
            rmsd_matrix[start_i:end_i, start_j:end_j] = rmsd

    if backend in {'torch', 'cuda'}:
        rmsd_matrix = rmsd_matrix.numpy()
    return rmsd_matrix